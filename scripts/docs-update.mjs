import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);
const repoRoot   = path.resolve(__dirname, '..');

const REQUIRED_VARS = new Set([
  'AIRTABLE_API_KEY','AIRTABLE_BASE_ID',
  'TB_RIGS','TB_DOCS','TB_SESSIONS','TB_ACTIONS','TB_READINGS','TB_FINDINGS',
  'TB_RULEPACKS','SESSIONS_RULEPACK_FIELD','BLOB_READ_WRITE_TOKEN'
]);
const OPTIONAL_VARS = new Set(['TB_EQUIP_TYPES','TB_RIG_EQUIP','TB_TECHS']);

function stamp(){ return new Date().toISOString().replace('T',' ').split('.')[0] + 'Z'; }
async function read(p){ return fs.readFile(p,'utf8'); }
async function write(p,c){ await fs.writeFile(p,c,'utf8'); }

function replaceBetween(text, startTag, endTag, inner){
  const s = text.indexOf(startTag);
  const e = text.indexOf(endTag);
  if (s === -1 || e === -1 || e < s) return text + `\n\n${startTag}\n${inner}\n${endTag}\n`;
  return text.slice(0, s + startTag.length) + '\n' + inner + '\n' + text.slice(e);
}

async function findApiRoutes(){
  const root = path.join(repoRoot, 'src', 'app', 'api');
  const routes = [];
  async function walk(dir, rel=''){
    let ents=[]; try { ents = await fs.readdir(dir, { withFileTypes:true }); } catch { return; }
    for (const ent of ents){
      const abs = path.join(dir, ent.name);
      const r   = path.join(rel, ent.name);
      if (ent.isDirectory()) await walk(abs, r);
      else if (/^route\.(t|j)sx?$/.test(ent.name)){
        const code = await read(abs);
        const methods = [];
        for (const m of ['GET','POST','PUT','PATCH','DELETE','HEAD','OPTIONS']){
          if (new RegExp(`export\\s+async\\s+function\\s+${m}\\b`).test(code)) methods.push(m);
        }
        const url = '/api/' + r.replace(/\\/g,'/').replace(/\/route\.(t|j)sx?$/,'');
        routes.push({ url, methods: methods.length ? methods : ['(dynamic)'] });
      }
    }
  }
  await walk(root);
  routes.sort((a,b)=>a.url.localeCompare(b.url));
  return routes;
}

async function extractEnvKeys(){
  const p = path.join(repoRoot, 'src', 'lib', 'airtable.ts');
  let code=''; try { code = await read(p); } catch {}
  const m = code.match(/envStatus[^]*?{([^]*?)}/);
  const keys = new Set();
  if (m){
    const objBody = m[1];
    for (const match of objBody.matchAll(/['"]([A-Z0-9_]+)['"]\s*:/g)){
      keys.add(match[1]);
    }
  }
  const required = [...keys].filter(REQUIRED_VARS.has, REQUIRED_VARS).sort();
  const optional = [...keys].filter(OPTIONAL_VARS.has, OPTIONAL_VARS).sort();
  const other    = [...keys].filter(k=>!REQUIRED_VARS.has(k) && !OPTIONAL_VARS.has(k)).sort();
  return { required, optional, other };
}

function renderEnvTable(envs){
  const rows = (arr, tag) => arr.map(k => `| \`${k}\` | ${tag} |`).join('\n');
  const body = [rows(envs.required, '**Required**'), rows(envs.optional, 'Optional'), rows(envs.other, 'Detected')]
               .filter(Boolean).join('\n');
  return [`> _autogenerated ${stamp()}_`,`| Variable | Requirement |`,`|---|---|`, body || `| (none found) | |`].join('\n');
}

function renderApiTable(routes){
  const lines = routes.map(r => `| \`${r.url}\` | ${r.methods.join(', ')} |`);
  return [`> _autogenerated ${stamp()}_`,`| Endpoint | Methods |`,`|---|---|`, lines.join('\n') || `| (none detected) | |`].join('\n');
}

async function updateDoc(fileRel, sections){
  const abs = path.join(repoRoot, fileRel);
  let text=''; try { text = await read(abs); } catch { text = ''; }
  for (const s of sections){ text = replaceBetween(text, s.start, s.end, s.content); }
  await write(abs, text);
  console.log(`updated ${fileRel}`);
}

async function main(){
  const envs   = await extractEnvKeys();
  const routes = await findApiRoutes();
  const envBlock = renderEnvTable(envs);
  const apiBlock = renderApiTable(routes);

  await updateDoc('README.md', [{ start:'<!-- AUTOGEN:ENV-START -->', end:'<!-- AUTOGEN:ENV-END -->', content: envBlock }]);
  await updateDoc('docs/QUICK_START.md', [{ start:'<!-- AUTOGEN:ENV-START -->', end:'<!-- AUTOGEN:ENV-END -->', content: envBlock }]);
  await updateDoc('docs/20-architecture.md', [{ start:'<!-- AUTOGEN:API-START -->', end:'<!-- AUTOGEN:API-END -->', content: apiBlock }]);
  await updateDoc('docs/40-runbook.md', [{ start:'<!-- AUTOGEN:API-START -->', end:'<!-- AUTOGEN:API-END -->', content: apiBlock }]);

  const changelog = path.join(repoRoot, 'CHANGELOG.md');
  let cl=''; try { cl = await read(changelog); } catch {}
  cl += `\n- ${stamp()} â€” docs autoupdate (ENV + API maps)\n`;
  await write(changelog, cl);
  console.log('updated CHANGELOG.md');
}

if (process.argv.includes('--check')){
  (async ()=>{
    const envs = await extractEnvKeys();
    const routes = await findApiRoutes();
    console.log('ENV (required):', envs.required);
    console.log('ENV (optional):', envs.optional);
    console.log('ENV (other):', envs.other);
    console.log('API routes:', routes);
  })();
} else {
  main().catch(e => { console.error(e); process.exit(1); });
}
